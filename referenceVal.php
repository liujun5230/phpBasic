<?php 

$k=234;
$ck = $bk = $dk = $k;

echo "\$ck".$ck."<br/>";
echo "\$bk".$bk."<br/>";
echo "\$dk".$dk."<br/>";
echo "\$k".$k."<br/>";

echo "<br/>=============<br/>";

$v2 =& $v1;
$v3 =& $v1;
$v4 =& $v1;
$v5 =& $v1;
$v6 =& $v1;
$v7 =& $v1;
$v8 =& $v1;

$c1 =& $v1;


$c2 =& $c1;
$c3 =& $c1;
$c4 =& $c1;
$c5 =& $c1;


//$c1 =& $v1;  
/*
如果像上面这样写，那么意味着之前$c2到$c5的引用赋值都指向$c1的初始化地址，
而这个地址的值是空。所以当这里插入$c1 =& $v1时，表示$c1从值为空的初始化地址，
指向了$v1的初始化地址，虽然同样值也为空，但地址不一样了。而因为这个引用赋值在后面，
$c2到$c5引用赋值$c1在先，所以$c2到$c5并不会指向$v1这个地址，所以就只是$c1指向了
$v1,$c2到$c5都不会指向$v1。

引用赋值，并没有谁赋给谁的问题，一旦进行引用赋值，就意味着多个变量名称指向同一个
内存位置，如果此时多个变量中的任意一个变量改变指向（注意是指向，不是值），都不会影响其他变量的指向，
这跟赋值一样，没有传导性。

例如下列引用赋值：
$v2 =& $v1; 
$v3 =& $v1; 
$v4 =& $v1;

如果我此时加一句：$v1 =& $c1;
那么不会是$v2到$v4全部指向$c1了，而是$v2到$v4依然指向$v1的初始化内存地址，
$v1则指向了$c1的地址。


*/

$v8 = 10;

$c4 = $v2+$v3;
$v2 = $c4+$v3;
$v3 = $v2+$c4;




echo "\$v1:".$v1."<br/>";
echo "\$v2:".$v2."<br/>";
echo "\$v3:".$v3."<br/>";
echo "\$v4:".$v4."<br/>";
echo "\$v5:".$v5."<br/>";
echo "\$v6:".$v6."<br/>";
echo "\$v7:".$v7."<br/>";
echo "\$v8:".$v8."<br/>";

echo "<br/>=============<br/>";


echo "\$c1:".$c1."<br/>";
echo "\$c2:".$c2."<br/>";
echo "\$c3:".$c3."<br/>";
echo "\$c4:".$c4."<br/>";
echo "\$c5:".$c5."<br/>";


echo "<br/>=============<br/>";

$cs1 = 666;

$vs1 = 0;
$vs2 = $vs1;
$vs3 = $vs1;
$vs4 = $vs1;

$vs1 = $cs1;


echo "\$vs1:".$vs1."<br/>";
echo "\$vs2:".$vs2."<br/>";
echo "\$vs3:".$vs3."<br/>";
echo "\$vs4:".$vs4."<br/>";
echo "\$cs1:".$cs1."<br/>";


?>